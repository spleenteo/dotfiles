" neobundle

if has('vim_starting')
  set nocompatible
  set runtimepath+=/Users/stefanoverna/.vim/bundle/neobundle.vim/
endif

call neobundle#begin(expand('/Users/stefanoverna/.vim/bundle'))

NeoBundleFetch 'Shougo/neobundle.vim'

" 16 colors colorscheme, for a uniform terminal experience
NeoBundle 'noahfrederick/vim-noctu'

" syntaxes
NeoBundle 'kchmck/vim-coffee-script'
NeoBundle 'slim-template/vim-slim'
NeoBundle 'othree/html5.vim'
NeoBundle 'pangloss/vim-javascript'
NeoBundle 'vim-ruby/vim-ruby'

" ruby stuff
NeoBundle 'stefanoverna/vim-plumber'
NeoBundle 'stefanoverna/vim-alternate'
NeoBundle 'jgdavey/vim-blockle'
NeoBundle 'stefanoverna/vim-reformat-call'

" adding end after if, do, def and several other keywords
NeoBundle 'tpope/vim-endwise'

" Git (used with airline)
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'airblade/vim-gitgutter'

" snippets
NeoBundle "MarcWeber/vim-addon-mw-utils"
NeoBundle "tomtom/tlib_vim"
NeoBundle "garbas/vim-snipmate"
NeoBundle "stefanoverna/snipmate-snippets"

" nice status line
NeoBundle 'bling/vim-airline'
" open files in specific line (eg. vim ~/foo.rb:12)
NeoBundle 'bogado/file-line'
" handy tmux-vim panes navigation
NeoBundle 'christoomey/vim-tmux-navigator'
" visual tab hints
NeoBundle 'nathanaelkane/vim-indent-guides'
" project drawer
NeoBundle 'scrooloose/nerdtree'
" smarter pasting
NeoBundle 'sickill/vim-pasta'
" %S
NeoBundle 'tpope/vim-abolish'
" Comment all the things
NeoBundle 'tpope/vim-commentary'
" cs"'
NeoBundle 'tpope/vim-surround'
" populate the argument list from the files in the quickfix list
NeoBundle 'henrik/vim-qargs'
" create missing directories on the fly
NeoBundle 'dockyard/vim-easydir'

" Rails I18n helpers
NeoBundle 'stefanoverna/vim-i18n'

" Menu
NeoBundle 'Shougo/unite.vim'

" dependencies
NeoBundle 'Shougo/vimproc', {
\ 'build' : {
\     'mac' : 'make -f make_mac.mak',
\    },
\ }
NeoBundle 'tmhedberg/matchit'
NeoBundle 'kana/vim-textobj-user'

call neobundle#end()
filetype plugin indent on

" If there are uninstalled bundles found on startup,
" this will conveniently prompt you to install them.
NeoBundleCheck

" The set nocompatible setting makes vim behave in a more useful way (the default) than the vi-compatible manner.
set nocompatible

" Enable syntax highlighting
syntax enable

" Tab command-line completion
set wildmenu
" Complete till longest common string, and open suggestions menu
set wildmode=longest:full
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.sass-cache/*,*/tmp/*

" Default charset encoding.
set encoding=utf-8

" Leader key
let mapleader=","

" Single line command status
set cmdheight=1

" My favourite syntax colorscheme (iterm 256 colors)
set t_Co=16
set background=dark
colorscheme noctu
hi VertSplit ctermbg=8 ctermfg=8
hi ColorColumn ctermbg=0 ctermfg=NONE

hi! link Define Function
hi! link Macro Function
hi! link Tag SpecialComment

" Line numbering
set number
" Show the cursor position all the time
set cursorline
" Silence bells
set noerrorbells

" Display incomplete commands
set showcmd

" Allow backgrounding buffers without writing them, and remember marks/undo
" for backgrounded buffers
set hidden

" == Whitespace ==
" Don't wrap lines
set nowrap
" A tab is two spaces
set tabstop=2
" An autoindent (with <<) is two spaces
set shiftwidth=2
" Use spaces, not tabs
set expandtab
" Show invisible characters
set list
" backspace through everything in insert mode
set backspace=indent,eol,start

" A tab should display as "▸", trailing whitespace as "·"
" precedes and extends are the characters to sho when wrap
" is off and the line continues beyond the right of the screen
set listchars=trail:·,precedes:«,extends:»,tab:→\ 

" == Searching ==
" Highlight matches
set hlsearch
" Incremental searching
set incsearch
" Searches are case insensitive...
set ignorecase
" ...unless they contain at least one capital letter
set smartcase
" clear the search buffer when hitting return (but preserve natural behaviour 
" in quickfix windows)
nnoremap <expr> <CR> (&buftype is# "quickfix" ? "<cr>" : ":\<C-u>nohlsearch\n")

" Treat JSON files like JavaScript
au BufNewFile,BufRead *.json set ft=javascript

" Thorfile, Rakefile, Vagrantfile and Gemfile are Ruby
au BufRead,BufNewFile {Podfile,Gemfile,Rakefile,Vagrantfile,Thorfile,config.ru} set ft=ruby

" Cakefile is Yaml
au BufRead,BufNewFile {Cakefile} set ft=coffee

" Remember last location in file, but not for commit messages.
autocmd BufReadPost *
  \ if &filetype !~ '^git\c' && line("'\"") > 0 && line("'\"") <= line("$") |
  \   exe "normal g`\"" |
  \ endif

au Filetype gitcommit setlocal textwidth=72 colorcolumn=72

" Automatically remove trailing spaces on some files (and fix tabs)
au BufWritePre *.rb,*.css,*.sass,*.scss,*.coffee :%s/\s\+$//e | :retab

" Slim comments start with /
autocmd FileType slim set commentstring=\/\ %s

" provide some context when editing
set scrolloff=3

set backupdir=~/.dotfiles/vim/_backup    " where to put backup files.
set directory=~/.dotfiles/vim/_temp      " where to put swap files.
set backupskip=/tmp/*,/private/tmp/*

" makes work arrows in visual mode
noremap <Up> <nop>
noremap <Down> <nop>
noremap <Left> <nop>
noremap <Right> <nop>

" == Ruby blocks ==
runtime macros/matchit.vim

" leader-l for fuzzy search
let g:unite_enable_start_insert = 1
let g:unite_cursor_line_highlight = 'CursorLine'
let g:unite_source_grep_search_word_highlight = 'Underlined'
let g:unite_source_line_search_word_highlight = 'Underlined'

let s:unite_ignores = [ '.git', 'log', 'node_modules', 'coverage' ]
call unite#custom#source('file_rec,file_rec/async,file_mru,file,buffer,grep',
  \ 'ignore_pattern', unite#get_all_sources('file_rec')['ignore_pattern'] .
  \ join(s:unite_ignores, '\|'))
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_length'])

nnoremap <silent> <leader>l :Unite -toggle -no-split -buffer-name=files file_rec/async:!<CR>

" leader-f for The Silver Searcher
let g:unite_source_grep_command = 'ag'
let g:unite_source_grep_default_opts =
\ '--line-numbers --nocolor --nogroup --hidden --ignore ' .
\  '''log'' --ignore ''.git'' --ignore ''coverage'' --ignore ''node_modules'''
let g:unite_source_grep_recursive_opt = ''
nnoremap <silent> <leader>f :Unite -toggle -no-split -no-start-insert -auto-preview -truncate grep:.<cr>

" == DestroyAllSoftware tips ==

" Switch between the last two files
nnoremap <leader><leader> <c-^>

" Open routes.rb
noremap <leader>gr :topleft :split config/routes.rb<cr>

" Open database.yml
noremap <leader>gd :topleft :split config/database.yml<cr>

" Open schema.rb
noremap <leader>gs :topleft :split db/schema.rb<cr>

" Open Gemfile
noremap <leader>gg :topleft :split Gemfile<cr>

" Can't be bothered to understand the difference between ESC and <c-c> in
" insert mode
inoremap <c-c> <esc>

" == colorpick ==
" Needs https://github.com/jnordberg/color-pick
function! ColorPick()
  let word = expand("<cword>")
  let hex = system('colorpick -startColor ' . word)
  if word =~ '\([a-fA-F1-9]\{3,6\}\)'
    execute "normal! ciw" . hex
  else
    execute "normal! a#" . hex
  endif
endfunction
nnoremap <leader>c :call ColorPick()<CR>

" == Vertical line at 80 chars ==
set colorcolumn=78

" == Paste from clipboard ==
set clipboard=unnamed " this needs vim 7.3 with +clipboard

" == Current line highlighter ==
au WinLeave * set nocursorline nocursorcolumn
au WinEnter * set cursorline
set cursorline
hi CursorLine cterm=NONE ctermbg=0

" == %% gets converted to directory of current file ==
cnoremap %% <C-R>=expand('%:h').'/'<cr>

" == Prefills :edit command with the current dir ==
map <leader>e :edit %%

" == Close VIM if the only window left open is a NERDTree
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

function! CustomTreeToggle()
  if !exists("t:NERDTreeBufName") || bufwinnr(t:NERDTreeBufName) == -1
    if strlen(expand("%:p")) > 0
      exec ':NERDTreeFind'
    else
      exec ':NERDTree'
    end
  else
    exec ':NERDTreeClose'
  endif
endfunction
noremap <leader>d :call CustomTreeToggle()<cr>

let NERDTreeHijackNetrw=1
let NERDTreeShowHidden=1

" == Mouse support
" Send more characters for redraws
set ttyfast
" Enable mouse use in all modes
set mouse=a
" Set this to the name of your terminal that supports mouse codes.
" Must be one of: xterm, xterm2, netterm, dec, jsbterm, pterm
set ttymouse=xterm2

" == Disable F1 opening help
nnoremap <F1> :echo<CR>
inoremap <F1> <C-o>:echo<CR>

" == Indent Guides
let g:indent_guides_auto_colors = 0
let g:indent_guides_enable_on_vim_startup = 1
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  ctermbg=0
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven ctermbg=NONE

" quick save and quit!
nnoremap s :w<CR>

" q closes buffer, Q records macros
nnoremap Q q
nnoremap q :q<CR>

" sessions
let g:session_directory = "."
let g:session_autoload = 'yes'
let g:session_autosave = 'yes'
set sessionoptions-=buffers

" no backup files
set nobackup
set nowritebackup
set noswapfile

" Move cursor by display lines when wrapping
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk

" Move to beginning and end of line easily
nnoremap H ^
nnoremap L $

" Let's make escape better, together.
inoremap jk <Esc>

" split
nnoremap <leader>v :execute "vsplit " . bufname("#")<CR>
nnoremap <leader>x :execute "split " . bufname("#")<CR>

" y u no consistent?
nnoremap Y y$

let NERDTreeIgnore=['node_modules', 'stubs', 'log', '.DS_Store']

" <leader>A runs all the specs
nnoremap <silent> <leader>A :<C-U>w \| call Plumber("rspec spec")<CR>

" Convert hashrockets into new 1.9 hash syntax
noremap <leader>rr :%s/:\(\w\+\)\s*=>/\1:/ge<CR><C-o>

" Remove trailing spaces
noremap <leader>ss :%s/\s\+$//e<CR><C-o>

function! AddTrailingNewLine()
  " \%$ -> end of file
  %s/[\r\n]*\%$/\r/
  exec "silent! normal! \<c-o>"
endfunction

" POSIX says a line is a sequence of zero or more non-newline characters plus
" a terminating newline character
autocmd BufWritePre * :call AddTrailingNewLine()

cmap w!! w !sudo tee %
command! KillControlM :normal :%s/<C-V><C-M>//e<CR><C-O><CR>

" More natural split opening
set splitbelow
set splitright

" Airline
" Always show the status bar
set laststatus=2
let g:airline_left_sep = ''
let g:airline_right_sep = ''
let g:airline_enable_syntastic = 0
let g:airline_enable_bufferline = 0
let g:airline_enable_branch = 1

let g:airline_linecolumn_prefix = '␊ '
let g:airline_linecolumn_prefix = '␤ '
let g:airline_linecolumn_prefix = '¶ '
let g:airline_branch_prefix = '⎇  '
let g:airline_paste_symbol = 'ρ'
let g:airline_theme='badwolf'

" Plumber
let g:plumber_precommand = 'plumber-exit-copy-mode'

" Git gutter
let g:gitgutter_realtime = 0
let g:gitgutter_eager = 0

" autocomplete keyword with \
inoremap <expr> \ '<C-n>'

" Cursor shapes
if exists("$TMUX")
  let &t_SI = "\<Esc>[3 q"
  let &t_EI = "\<Esc>[0 q"
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" Insert only one space when joining lines that contain sentence-terminating
" punctuation like `.`.
set nojoinspaces

" Saves current file and reloads current Chrome tab
map <leader>z :w\|:silent !reload-chrome<cr>\|:redraw!<cr>

" Promote variable to Rspec let
function! PromoteToLet()
  normal! dd
  " :exec '?^\s*it\>'
  normal! P
  .s/\(\w\+\) = \(.*\)$/let(:\1) { \2 }/
  normal ==
endfunction
command! PromoteToLet :call PromoteToLet()
map <leader>p :PromoteToLet<cr>

" I CAN HAZ NORMAL REGEXES?
nnoremap / /\v
vnoremap / /\v

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" select last paste in visual mode
nnoremap <expr> vv '`[' . strpart(getregtype(), 0, 1) . '`]'

" reformat method call/function call/hash
map <leader>u :ReformatCall<cr>

" I18n
vmap <Leader>z :call I18nTranslateString()<CR>

" show buffer list as tabs
" let g:airline#extensions#tabline#enabled = 1
" let g:airline#extensions#tabline#buffer_nr_show = 1
" let g:airline#extensions#tabline#buffer_nr_format = '%s: '

" Test quickfix list management: If the tests write a tmp/quickfix file, these 
" mappings will navigate through it

function! GetBufferList()
  redir =>buflist
  silent! ls
  redir END
  return buflist
endfunction

function! BufferIsOpen(bufname)
  let buflist = GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      return 1
    endif
  endfor
  return 0
endfunction

function! ToggleQuickfix()
  if BufferIsOpen("Quickfix List")
    cclose
  else
    call OpenQuickfix()
  endif
endfunction

function! OpenQuickfix()
  cgetfile tmp/quickfix
  topleft cwindow
  if &ft == "qf"
      cc
  endif
endfunction

nnoremap <leader>q :call ToggleQuickfix()<cr>
nnoremap <leader>Q :cc<cr>
nnoremap <leader>j :cnext<cr>
nnoremap <leader>k :cprev<cr>

